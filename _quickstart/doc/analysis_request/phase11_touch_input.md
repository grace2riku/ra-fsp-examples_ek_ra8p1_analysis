# Phase 11: タッチ入力解析

## カテゴリ
機能編

## 概要
LCD画面タッチの仕組みを詳細に解析し、タッチ入力からイベント処理までの流れを理解する。

## 解析要求事項

LCD画面タッチの仕組みを詳細に解析してください。

### 1. タッチハードウェア

#### タッチコントローラIC

| 項目 | 値 |
|------|-----|
| IC型番 | ? |
| 接続方式 | I2C / SPI |
| I2Cアドレス | 0x?? |
| タッチ方式 | 静電容量式 / 抵抗膜式 |
| マルチタッチ対応 | 有/無（最大?点） |

#### 接続ピン

| 信号 | ピン番号 | 説明 |
|------|----------|------|
| SDA | ? | I2Cデータ |
| SCL | ? | I2Cクロック |
| INT | ? | 割込み出力 |
| RST | ? | リセット入力 |

### 2. タッチドライバ

#### タッチデータ取得方法

| 方式 | 説明 |
|------|------|
| ポーリング | 定期的にI2C読み出し |
| 割込み | INTピンからの割込みで読み出し |

実際の方式: ?

#### 座標データ形式

```c
// タッチデータ構造体（例）
typedef struct {
    uint16_t x;        // X座標
    uint16_t y;        // Y座標
    uint8_t  status;   // タッチ状態
    uint8_t  id;       // タッチID（マルチタッチ時）
} touch_data_t;
```

#### 座標変換処理

| 処理 | 説明 |
|------|------|
| スケーリング | タッチ座標 → 画面座標への変換 |
| キャリブレーション | 位置ズレ補正 |
| フィルタリング | ノイズ除去 |

### 3. タッチ座標領域の定義

#### ボタン/タッチ領域の定義方法

調査項目：
- 座標領域を定義しているファイル
- 定義に使用している構造体/配列
- 領域の追加・変更方法

```c
// タッチ領域定義の例
typedef struct {
    uint16_t x_min;
    uint16_t y_min;
    uint16_t x_max;
    uint16_t y_max;
    uint8_t  id;
    void (*callback)(void);
} touch_region_t;

// 領域配列の例
static const touch_region_t touch_regions[] = {
    { 10, 10, 100, 50, BUTTON_ID_OK, button_ok_handler },
    { 120, 10, 210, 50, BUTTON_ID_CANCEL, button_cancel_handler },
    // ...
};
```

#### 画面ごとの領域定義

| 画面名 | 領域数 | 定義場所 |
|--------|--------|----------|
| ホーム画面 | ? | ? |
| 設定画面 | ? | ? |
| カメラ画面 | ? | ? |

### 4. タッチ判定処理

#### タッチ状態の種類

| 状態 | 説明 |
|------|------|
| TOUCH_DOWN | タッチ開始 |
| TOUCH_MOVE | タッチ移動（ドラッグ） |
| TOUCH_UP | タッチ終了 |

#### 領域判定ロジック

```c
// 判定処理の擬似コード
bool is_inside_region(touch_data_t *touch, touch_region_t *region) {
    return (touch->x >= region->x_min &&
            touch->x <= region->x_max &&
            touch->y >= region->y_min &&
            touch->y <= region->y_max);
}
```

#### ジェスチャー認識（あれば）

| ジェスチャー | 認識条件 |
|-------------|----------|
| タップ | 短時間のタッチ＆リリース |
| ロングプレス | 長時間のタッチ |
| スワイプ | 一定距離の移動 |
| ピンチ | 2点タッチの距離変化 |

### 5. イベント処理フロー

#### タッチ検出からイベント発火までの流れ

```
タッチ発生
    │
    ▼
INT割込み発生
    │
    ▼
割込みハンドラ
    │
    ├─→ I2Cでタッチデータ読み出し
    │
    └─→ タッチイベント生成
    │
    ▼
座標変換処理
    │
    ▼
領域判定処理
    │
    ├─→ 領域内: コールバック呼び出し
    │
    └─→ 領域外: GUIライブラリへ通知
    │
    ▼
GUIイベント処理
    │
    ▼
アプリケーション処理
```

#### コールバック関数の登録方法

```c
// 登録方法の例
void register_touch_callback(uint8_t region_id, touch_callback_t callback);
```

#### GUIライブラリへのイベント伝達

| GUIライブラリ | イベント伝達API |
|--------------|-----------------|
| emWin | GUI_TOUCH_StoreStateEx() |
| GUIX | gx_system_event_send() |
| LVGL | lv_indev_read_cb() |

## 期待する成果物

### 1. タッチシステムブロック図

ハードウェアからアプリケーションまでのタッチ処理システム全体図を作成してください。

### 2. タッチ処理シーケンス図

タッチ検出からイベント処理までのシーケンス図を作成してください。

### 3. 領域定義の方法と例

タッチ領域の定義方法と実際のコード例を示してください。

### 4. カスタマイズガイド

- 新しいタッチ領域の追加方法
- タッチ感度の調整方法
- ジェスチャー追加方法（可能な場合）

### 5. デバッグ方法

- タッチ座標の確認方法
- タッチイベントのログ出力
- トラブルシューティング
